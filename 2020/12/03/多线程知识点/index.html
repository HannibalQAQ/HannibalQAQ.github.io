<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>多线程知识点 | 木子文昍</title><meta name="author" content="Hannibal"><meta name="copyright" content="Hannibal"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="多线程知识点线程和进程的区别？根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。关系：一个程序至少一个进程，一个进程至少一个线程。 Thread和Runnable的关系，区别1） Runnable 是接口。Thread 是类，且实现了Runnable接口。2） 实现Runnable接口相比继承T">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程知识点">
<meta property="og:url" content="http://liwenchang.ren/2020/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="木子文昍">
<meta property="og:description" content="多线程知识点线程和进程的区别？根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。关系：一个程序至少一个进程，一个进程至少一个线程。 Thread和Runnable的关系，区别1） Runnable 是接口。Thread 是类，且实现了Runnable接口。2） 实现Runnable接口相比继承T">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">
<meta property="article:published_time" content="2020-12-03T11:49:40.000Z">
<meta property="article:modified_time" content="2020-12-03T11:54:24.188Z">
<meta property="article:author" content="Hannibal">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://liwenchang.ren/2020/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2020-12-03 19:54:24'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/null" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">木子文昍</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><h1 class="post-title">多线程知识点</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-03T11:49:40.000Z" title="发表于 2020-12-03 19:49:40">2020-12-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-12-03T11:54:24.188Z" title="更新于 2020-12-03 19:54:24">2020-12-03</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="多线程知识点"><a href="#多线程知识点" class="headerlink" title="多线程知识点"></a>多线程知识点</h1><h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。<br>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。<br>关系：一个程序至少一个进程，一个进程至少一个线程。</p>
<h2 id="Thread和Runnable的关系，区别"><a href="#Thread和Runnable的关系，区别" class="headerlink" title="Thread和Runnable的关系，区别"></a>Thread和Runnable的关系，区别</h2><p>1） Runnable 是接口。Thread 是类，且实现了Runnable接口。<br>2） 实现Runnable接口相比继承Thread类有如下好处：避免继承的局限，一个类可以实现多个接口。</p>
<h2 id="synchronized底层如何实现"><a href="#synchronized底层如何实现" class="headerlink" title="synchronized底层如何实现"></a>synchronized底层如何实现</h2><p>synchronized 是 Java 内建的同步机制，所以也有人称其为 Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p>
<p>原理：<br>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性</p>
<p>底层实现：<br>1）同步代码块是使用monitorenter和monitorexit指令实现的， ，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；<br>2）同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。 synchronized方法是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示 Klass 做为锁对象。</p>
<p><strong>Java对象头和monitor是实现synchronized的基础！</strong></p>
<h2 id="synchronized存放的位置"><a href="#synchronized存放的位置" class="headerlink" title="synchronized存放的位置:"></a>synchronized存放的位置:</h2><p>synchronized用的锁是存在Java对象头里的。<br>其中， Java对象头包括：<br>Mark Word（标记字段）： 用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。它是实现轻量级锁和偏向锁的关键<br>Klass Pointer（类型指针）： 是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例<br>monitor: 可以把它理解为一个同步工具， 它通常被描述为一个对象。 是线程私有的数据结构。</p>
<h2 id="锁优化，怎么优化？"><a href="#锁优化，怎么优化？" class="headerlink" title="锁优化，怎么优化？"></a>锁优化，怎么优化？</h2><p>jdk1.6对锁的实现引入了大量的优化。 </p>
<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。 注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。 </p>
<p>重量级锁降级发生于STW（Stop-The-World）阶段，降级对象为仅仅能被VMThread访问而没有其他JavaThread访问的对象。（ HotSpot JVM/JRockit JVM是支持锁降级的）<br>偏斜锁：<br>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。<br>自旋锁：<br>自旋锁 for(;;)结合cas确保线程获取取锁<br>就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。<br>轻量级锁：<br>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。 当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁<br>重量级锁：<br>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<h2 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h2><p>synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。</p>
<h2 id="锁的升级的目的"><a href="#锁的升级的目的" class="headerlink" title="锁的升级的目的"></a>锁的升级的目的</h2><p>锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>
<h2 id="Synchronized和Lock的区别？"><a href="#Synchronized和Lock的区别？" class="headerlink" title="Synchronized和Lock的区别？"></a>Synchronized和Lock的区别？</h2><p>1）实现层面：synchronized（JVM层面）、Lock（JDK层面）<br>2）响应中断：Lock 可以让等待锁的线程响应中断，而使用synchronized时，等待的线程会一直等待下去，不能够响应中断；<br>3）立即返回：可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间，而synchronized却无法办到；<br>4）读写锁：Lock可以提高多个线程进行读操作的效率<br>5）可实现公平锁：Lock可以实现公平锁，而sychronized天生就是非公平锁<br>6）显式获取和释放：synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p>
<h2 id="synchronized和ReentrantLock有什么区别呢？"><a href="#synchronized和ReentrantLock有什么区别呢？" class="headerlink" title="synchronized和ReentrantLock有什么区别呢？"></a>synchronized和ReentrantLock有什么区别呢？</h2><p>synchronized 是 Java 内建的同步机制，所以也有人称其为 Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。<br>ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制。编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p>
<p>1）ReentrantLock 使用起来比较灵活，可以对获取锁的等待时间进行设置，可以获取各种锁的信息，但是必须有释放锁的配合动作；<br>2）ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁；<br>3）ReentrantLock 只适用于代码块锁，而 synchronized 可用于修饰方法、代码块等。<br>4）synchronized是关键字，ReentrantLock是类<br>5）Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的<br>6）ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。<br>7）ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。<br>8）ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。</p>
<p>场景：<br>在确实需要一些 synchronized 所没有的特性的时候，比如时间锁等候、可中断锁等候、无块结构锁、多个条件变量或者锁投票。 ReentrantLock 还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记住，大多数 synchronized 块几乎从来没有出现过争用，所以可以把高度争用放在一边。我建议用 synchronized 开发</p>
<h2 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h2><p>1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作<br>线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。<br>2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这<br>个工作队列里。如果工作队列满了，则进入下个流程。<br>3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程<br>来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</p>
<h2 id="线程池的作用"><a href="#线程池的作用" class="headerlink" title="线程池的作用"></a>线程池的作用</h2><p>减少资源的开销 可以减少每次创建销毁线程的开销提高响应速度 由于线程已经创建成功提高线程的可管理性</p>
<h2 id="实现线程池"><a href="#实现线程池" class="headerlink" title="实现线程池"></a>实现线程池</h2><p>主要有两部分组成，多个工作线程和一个阻塞队列。其中 工作线程是一组已经处在运行中的线程，它们不断地向阻塞队列中领取任务执行。而 阻塞队列用于存储工作线程来不及处理的任务。</p>
<h2 id="线程的组成创建一个线程池需要要的一些核心参数。"><a href="#线程的组成创建一个线程池需要要的一些核心参数。" class="headerlink" title="线程的组成创建一个线程池需要要的一些核心参数。"></a>线程的组成创建一个线程池需要要的一些核心参数。</h2><p>corePoolSize：基本线程数量 它表示你希望线程池达到的一个值。线程池会尽量把实际线程数量保持在这个值上下。<br>maximumPoolSize：最大线程数量 这是线程数量的上界。 如果实际线程数量达到这个值： 阻塞队列未满：任务存入阻塞队列等待执行 阻塞队列已满：调用饱和策略 。keepAliveTime：空闲线程的存活时间 当实际线程数量超过corePoolSize时，若线程空闲的时间超过该值，就会被停止。 PS：当任务很多，且任务执行时间很短的情况下，可以将该值调大，提高线程利用率。<br>timeUnit：keepAliveTime的单位<br>runnableTaskQueue：任务队列 这是一个存放任务的阻塞队列，可以有如下几种选择：1）ArrayBlockingQueue 它是一个由数组实现的阻塞队列，FIFO。<br>2） LinkedBlockingQueue 它是一个由链表实现的阻塞队列，FIFO。 吞吐量通常要高于<br>3）ArrayBlockingQueue。fixedThreadPool使用的阻塞队列就是它。 它是一个无界队列。 4）SynchronousQueue 它是一个没有存储空间的阻塞队列，任务提交给它之后必须要交给一条工作线程处理；如果当前没有空闲的工作线程，则立即创建一条新的工作线程。 cachedThreadPool用的阻塞队列就是它。 它是一个无界队列。<br>5）PriorityBlockingQueue 它是一个优先权阻塞队列。handler：饱和策略 当实际线程数达到maximumPoolSize，并且阻塞队列已满时，就会调用饱和策略。<br>AbortPolicy 默认。直接抛异常。 CallerRunsPolicy 只用调用者所在的线程执行任务。 DiscardOldestPolicy 丢弃任务队列中最久的任务。 DiscardPolicy 丢弃当前任务。</p>
<h2 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h2><p>当有请求到来时：<br>1.若当前实际线程数量 少于 corePoolSize，即使有空闲线程，也会创建一个新的工作线程；2 若当前实际线程数量处于corePoolSize和maximumPoolSize之间，并且阻塞队列没满，则任务将被放入阻塞队列中等待执行；<br>3.若当前实际线程数量 小于 maximumPoolSize，但阻塞队列已满，则直接创建新线程处理任务；<br>4.若当前实际线程数量已经达到maximumPoolSize，并且阻塞队列已满，则使用饱和策略。</p>
<h2 id="Java-并发类库提供的线程池有哪几种"><a href="#Java-并发类库提供的线程池有哪几种" class="headerlink" title="Java 并发类库提供的线程池有哪几种"></a>Java 并发类库提供的线程池有哪几种</h2><p>Executors 目前提供了 5 种不同的<br>线程池创建配置：<br>1）newCachedThreadPool()：用来处理大量短时间工作任务的线程池。</p>
<p><strong>当无缓存线程可用时，就会创建新的工作线程</strong>；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；其内部使用 SynchronousQueue 作为工作队列。<br>2）newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。<br>3）newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态<br>4）newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。<br>5）newWorkStealingPool(int parallelism)，Java 8 才加入这个创建方法，并行地处理任务，不保证处理顺序。<br>6）ThreadPoolExecutor()：是最原始的线程池创建，上面1-3创建方式都是对ThreadPoolExecutor的封装。</p>
<h2 id="ReentrantLock-底层实现-可重入锁"><a href="#ReentrantLock-底层实现-可重入锁" class="headerlink" title="ReentrantLock 底层实现  可重入锁"></a>ReentrantLock 底层实现  可重入锁</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011202334/article/details/73188404">https://blog.csdn.net/u011202334/article/details/73188404</a></p>
<p>lock  unlock</p>
<p>AQS原理：<br>AQS和Condition各自维护了不同的队列，在使用lock和condition的时候，其实就是两个队列的互相移动。如果我们想自定义一个同步器，可以实现AQS。它提供了获取共享锁和互斥锁的方式，都是基于对state操作而言的。</p>
<p>概念+实现：<br>ReentrantLock实现了Lock接口，是AQS( 一个用来构建锁和同步工具的框架， AQS没有 锁之 类的概念)的一种。加锁和解锁都需要显式写出，注意一定要在适当时候unlock。ReentranLock这个是可重入的。其实要弄明白它为啥可重入的呢，咋实现的呢。其实它内部自定义了同步器Sync，这个又实现了AQS，同时又实现了AOS，而后者就提供了一种互斥锁持有的方式。其实就是每次获取锁的时候，看下当前维护的那个线程和当前请求的线程是否一样，一样就可重入了。</p>
<p>和synhronized相比：<br>synchronized相比，ReentrantLock用起来会复杂一些。在基本的加锁和解锁上，两者是一样的，所以无特殊情况下，推荐使用synchronized。ReentrantLock的优势在于它更灵活、更强大，增加了轮训、超时、中断等高级功能。<br>1)可重入锁。可重入锁是指同一个线程可以多次获取同一把锁。ReentrantLock和synchronized都是可重入锁。<br>2)可中断锁。可中断锁是指线程尝试获取锁的过程中，是否可以响应中断。synchronized是<br>不可中断锁，而ReentrantLock则z,dz提供了中断功能。<br>3)公平锁与非公平锁。公平锁是指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。</p>
<h2 id="lock-和unlock-是怎么实现的呢？"><a href="#lock-和unlock-是怎么实现的呢？" class="headerlink" title="lock()和unlock()是怎么实现的呢？"></a>lock()和unlock()是怎么实现的呢？</h2><p>由lock()和unlock的源码可以看到，它们只是分别调用了sync对象的lock()和release(1)方法。而Sync是ReentrantLock的内部类， 其扩展了AbstractQueuedSynchronizer。</p>
<p>lock()：<br>final void lock() {<br>if (compareAndSetState(0, 1))<br>setExclusiveOwnerThread(Thread.currentThread());<br>else<br>acquire(1);<br>}<br>}</p>
<p>首先用一个CAS操作，判断state是否是0（表示当前锁未被占用），如果是0则把它置为1，并且设置当前线程为该锁的独占线程，表示获取锁成功。当多个线程同时尝试占用同一个锁时，CAS操作只能保证一个线程操作成功，剩下的只能乖乖的去排队啦。（ “非公平”即体现在这里）。<br>设置state失败，走到了else里面。我们往下看acquire。</p>
<p>第一步。尝试去获取锁。如果尝试获取锁成功，方法直接返回。</p>
<p>第二步，入队。（ 自旋+CAS组合来实现非阻塞的原子操作）</p>
<p>第三步，挂起。 让已经入队的线程尝试获取锁，若失败则会被挂起</p>
<p>public final void acquire(int arg) {<br>if (!tryAcquire(arg) &amp;&amp;<br>​    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>​    selfInterrupt();<br>}<br>流程大致为先尝试释放锁，若释放成功，那么查看头结点的状态是否为SIGNAL，如果是则唤醒头结点的下个节点关联的线程，<br>如果释放失败那么返回false表示解锁失败。这里我们也发现了，每次都只唤起头结点的下一个节点关联的线程。</p>
<p>public void unlock() {<br>sync.release(1);<br>}<br>public final boolean release(int arg) {<br>if (tryRelease(arg)) {<br>Node h = head;<br>if (h != null &amp;&amp; h.waitStatus != 0)<br>unparkSuccessor(h);<br>return true;<br>}<br>return false;<br>}</p>
<h2 id="AtomicInteger底层实现原理是什么？"><a href="#AtomicInteger底层实现原理是什么？" class="headerlink" title="AtomicInteger底层实现原理是什么？"></a>AtomicInteger底层实现原理是什么？</h2><p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作，以 volatile 的 value 字段，记录数值，以保证可见性，Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。</p>
<h2 id="voliate-的实现原理"><a href="#voliate-的实现原理" class="headerlink" title="voliate 的实现原理"></a>voliate 的实现原理</h2><p>volatile可以保证<strong>线程可见性且禁止指令重排序</strong>，但是<strong>无法保证原子性</strong>。</p>
<p>在JVM底层volatile是采用“内存屏障”来实现的， 加入volatile关键字时，汇编后会多出一个lock前缀指令。lock前缀指令其实就相当于一个内存屏障。。<br>happen-before原则保证了程序的“有序性，对volatile变量的写操作 happen-before 后续的读操作.<br>当读取一个被volatile修饰的变量时，会直接从共享内存中读，而非线程专属的存储空间中读。<br>当volatile变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程B再需要读取从主内存中去读取该变量的最新值。<br>对该变量的写操作之后，编译器会插入一个写屏障。对该变量的读操作之前，编译器会插入一个读屏障。<br>线程写入，写屏障会通过类似强迫刷出处理器缓存的方式，让其他线程能够拿到最新数值。<br>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<h2 id="happens-before原则有哪些："><a href="#happens-before原则有哪些：" class="headerlink" title="happens-before原则有哪些："></a>happens-before原则有哪些：</h2><p>程序顺序规则：单线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作；</p>
<p>锁定规则：一个unlock操作先行发生于对同一个锁的lock操作；</p>
<p>volatile变量规则：对一个Volatile变量的写操作先行发生于对这个变量的读操作；</p>
<p>线程启动规则：Thread对象的start()方法先行发生于此线程的其他动作；</p>
<p>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；</p>
<p>线程终止规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；</p>
<p>对象终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始；</p>
<p>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；</p>
<h2 id="synchronized-和-volatile-的区别是什么？"><a href="#synchronized-和-volatile-的区别是什么？" class="headerlink" title="synchronized 和 volatile 的区别是什么？"></a>synchronized 和 volatile 的区别是什么？</h2><ul>
<li>volatile 是变量修饰符；synchronized 是修饰类、方法、代码段。</li>
<li>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</li>
<li>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
</ul>
<h2 id="ThreadLocal的底层原理"><a href="#ThreadLocal的底层原理" class="headerlink" title="ThreadLocal的底层原理"></a>ThreadLocal的底层原理</h2><p>ThreadLocal，该类提供了线程局部 (thread-local) 变量，ThreadLocal会为每个线程创建变量的副本，线程之间互不影响，这样就不存在线程安全问题。在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals用来存储实际的变量副本容器, 键值为当前ThreadLocal变量，value为变量副本。<br>1）初始时，在Thread的threadLocals为空，调用ThreadLocal变量调用get()方法或者set()方法，就会对threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals中。<br>2）然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。</p>
<p>概括：<br>ThreadLocal，很多地方叫做线程本地变量，因为ThreadLocal在每个线程中对该变量会创建一个副本，即每个线程内部都会有一个该变量，且在线程内部任何地方都可以使用，线程之间互不影响，这样一来就不存在线程安全问题，也不会严重影响程序执行性能。在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。ThreadLocal相当于一个工具包，提供了操作该容器的方法，如get、set、remove等。在进行get之前，必须先set，否则会报空指针异常；否则必须重写initialValue()方法。<br>场景：数据库连接和session管理<br>该类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。<br>每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。<br>使用：<br>set(obj)：向当前线程中存储数据 get()：获取当前线程中的数据 remove()：删除当前线程中的数据</p>
<p>实现原理：<br>ThreadLocal并不维护ThreadLocalMap（ThreadLocalMap是Thread的）并不是一个存储数据的容器，它只是相当于一个工具包，提供了操作该容器的方法，如get、set、remove等。而ThreadLocal内部类ThreadLocalMap才是存储数据的容器，并且该容器由Thread维护。 每一个Thread对象均含有一个ThreadLocalMap类型的成员变量threadLocals，它存储本线程中所有ThreadLocal对象及其对应的值（ ThreadLocalMap 是个弱引用类，内部 一个Entry由ThreadLocal对象和Object构成，<br>为什么要用弱引用呢？<br>如果是直接new一个对象的话，使用完之后设置为null后才能被垃圾收集器清理，如果为弱引用，使用完后垃圾收集器自动清理key，程序员不用再关注指针。）<br>操作细节<br>进行set，get等操作都是首先会获取当前线程对象，然后获取当前线程的ThreadLocalMap对象。再以当前ThreadLocal对象为key ，再做相应的处理。<br>内存泄露问题<br>在ThreadLocalMap中，只有key是弱引用，value仍然是一个强引用。<br>每次操作set、get、remove操作时，ThreadLocal都会将key为null的Entry删除，从而避免内存泄漏。<br>当然，当 如果一个线程运行周期较长，而且将一个大对象放入LocalThreadMap后便不再调用set、get、remove方法，此时该仍然可能会导致内存泄漏。 这个问题确实存在，没办法通过ThreadLocal解决，而是需要程序员在完成ThreadLocal的使用后要养成手动调用remove的习惯，从而避免内存泄漏。</p>
<p>使用场景<br>Web系统Session的存储<br>当请求到来时，可以将当前Session信息存储在ThreadLocal中，在请求处理过程中可以随时使用Session信息，每个请求之间的Session信息互不影响。当请求处理完成后通过remove方法将当前Session信息清除即可。</p>
<p>ThreadLocal是如何为每个线程创建变量的副本的<br>首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。<br>　　初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。<br>　　然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。<br>总结：<br>1）实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的；<br>2）为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；<br>3）在进行get之前，必须先set，否则会报空指针异常；<br>　　 如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。 因为在上面的代码分析过程中，我们发现如果没有先set的话，即在map中查找不到对应的存储，则会通过调用setInitialValue方法返回i，而在setInitialValue方法中，有一个语句是T value = initialValue()， 而默认情况下，initialValue方法返回的是null。</p>
<h2 id="线程池的几种方式与使用场景"><a href="#线程池的几种方式与使用场景" class="headerlink" title="线程池的几种方式与使用场景"></a>线程池的几种方式与使用场景</h2><p>1、newFixedThreadPool创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。适用：执行长期的任务，性能好很多<br>2、newCachedThreadPool创建一个可缓存的线程池。这种类型的线程池特点是：<br>1).工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。<br>2).如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。<br>适用：执行很多短期异步的小程序或者负载较轻的服务器</p>
<p>3、newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行(我觉得这点是它的特色)。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的 。<br>适用：一个任务一个任务执行的场景</p>
<p>4、newScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer。(这种线程池原理暂还没完全了解透彻)<br>适用：周期性执行任务的场景</p>
<h2 id="JUC包中CountDownLatch-CyclicBarrier之间的区别，使用场景"><a href="#JUC包中CountDownLatch-CyclicBarrier之间的区别，使用场景" class="headerlink" title="JUC包中CountDownLatch CyclicBarrier之间的区别，使用场景"></a>JUC包中CountDownLatch CyclicBarrier之间的区别，使用场景</h2><p>概括性的：<br>CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。<br>CyclicBarrier : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。<br>细分：<br>CountDownLatch简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并且调用countDown()方法发出通知后，当前线程才可以继续执行。<br>cyclicBarrier是所有线程都进行等待，直到所有线程都准备好进入await()方法之后，所有线程同时开始执行！</p>
<p>1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：<br>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；<br>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；<br>2）CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。<br>3）CyclicBarrier还提供其他有用的方法，比如getNumberWaiting方法可以获得CyclicBarrier阻塞的线程数量。isBroken方法用来知道阻塞的线程是否被中断。</p>
<p>使用场景：<br>需要等待某个条件达到要求后才能做后面的事情；同时当线程都完成后也会触发事件，可以使用CountDownLatch<br>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的应用场景。<br>Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限，作用是限制某段代码块的并发数。</p>
<h2 id="死锁是什么，产生死锁的条件。如何避免死锁？"><a href="#死锁是什么，产生死锁的条件。如何避免死锁？" class="headerlink" title="死锁是什么，产生死锁的条件。如何避免死锁？"></a>死锁是什么，产生死锁的条件。如何避免死锁？</h2><p>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。<br>互斥条件：一个资源每次只能被一个进程使用。<br>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。<br>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 避免： 1）尽量避免使用多个锁，并且只有需要时才持有锁定位死锁，嵌套的 synchronized 或者 lock 非常容易出问题。<br>2）如果必须使用多个锁，尽量设计好锁的获取顺序<br>3）使用带超时的方法，为程序带来更多可控性。Object.wait(…) 或者 CountDownLatch.await(…)，都支持所谓的 timed_wait。<br>4）尽量不要几个功能用同一把锁。</p>
<h2 id="怎么定位死锁线程？"><a href="#怎么定位死锁线程？" class="headerlink" title="怎么定位死锁线程？"></a>怎么定位死锁线程？</h2><p>最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。<br>如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。<br>首先，可以使用 jps 或者系统的 ps 命令、任务管理器等工具，确定进程 ID。<br>其次，调用 jstack 获取线程栈：${JAVA_HOME}\bin\jstack your_pid<br>然后，分析得到的输出</p>
<h2 id="volatile-变量和-atomic-变量有什么不同？"><a href="#volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="volatile 变量和 atomic 变量有什么不同？"></a>volatile 变量和 atomic 变量有什么不同？</h2><p>volatile 变量和 atomic 变量看起来很像，但功能却不一样。</p>
<p>Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。</p>
<p>例如用volatile修饰count变量那么 count++ 操作就不是原子性的。</p>
<p>而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h2 id="Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>Java多线程中调用wait() 和 sleep()方法有什么不同？</h2><p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。需要注意的是，sleep（）并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为Runnable，并且根据线程调度，它将得到执行。<br>java.util.Timer是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer类可以用安排一次性任务或者周期任务。<br>java.util.TimerTask是一个实现了Runnable接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用Timer去安排它的执行。</p>
<h2 id="什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h2><p>原子操作是指一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的手段。<br>int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。<br>在 java.util.concurrent.atomic 包中添加原子变量类之后，这种情况才发生了改变。所有原子变量类都公开比较并设置原语（与比较并交换类似），这些原语都是使用平台上可用的最快本机结构（比较并交换、加载链接/条件存储，最坏的情况下是旋转锁）来实现的。</p>
<p> java.util.concurrent.atomic 包中提供了原子变量的 9 种风格（ AtomicInteger； AtomicLong； AtomicReference； AtomicBoolean；原子整型；长型；引用；及原子标记引用和戳记引用类的数组形式，其原子地更新一对值）。</p>
<p>一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。<br>Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误</p>
<h2 id="线程的状态有哪些-？"><a href="#线程的状态有哪些-？" class="headerlink" title="线程的状态有哪些 ？"></a>线程的状态有哪些 ？</h2><p>状态：在 Java 5 以后，线程状态被明确定义在其公共内部枚举类型 java.lang.Thread.State：<br>新建（NEW）new，表示线程被创建出来还没真正启动的状态<br>就绪,运行（RUNNABLE）runnable，表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。<br>在其他一些分析中，会额外区分一种状态 RUNNING，但是从 Java API 的角度，并不能表示出来。<br>阻塞（BLOCKED）blocked，这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。<br>等待（WAITING）waiting，表示正在等待其他线程采取某些操作。<br>计时等待（TIMED_WAIT）timed_wait：其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，<br>终止（TERMINATED）terminated，不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。</p>
<h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run() 和 start() 有什么区别？"></a>线程的 run() 和 start() 有什么区别？</h2><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。</p>
<p>run() 可以重复调用，而 start() 只能调用一次。<br>底层start()方法是使用C语言写的，调用JVM_startThread，开启子线程，然后调用里面的run方法</p>
<h2 id="Runnable和Callable的区别"><a href="#Runnable和Callable的区别" class="headerlink" title="Runnable和Callable的区别"></a>Runnable和Callable的区别</h2><p>Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。<br>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。<br>Call方法可以抛出异常，run方法不可以。<br>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS是compare and swap的缩写，即我们所说的比较交换。<br>cas是一种乐观锁。CAS<br>操作包含三个操作数 ——内存位置（V）、预期原值（A）和新值(B)。 当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。<br>缺点：<br>1）ABA问题：一个线程a将数值改成了b，接着又改成了a，此时CAS认为是没有变化，其实是已经变化过了。<br>解决办法：可以使用版本号标识，每操作一次version加1。在java5中，已经提供了AtomicStampedReference来解决问题。<br>2）CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。<br>3）CAS造成CPU利用率增加。</p>
<h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><p>AQS是AbustactQueuedSynchronizer的简称，它是一个Java提供的底层同步工具类，用一个int类型的变量表示同步状态，并提供了一系列的CAS操作来管理这个同步状态。使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore<br>技术是 CAS自旋Volatile变量：它使用了一个Volatile成员变量表示同步状态，通过CAS修改该变量的值，修改成功的线程表示获取到该锁；若没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒。<br>AQS维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）</p>
<p>（final）不可变对象对多线程有什么帮助？为什么喜欢用final变量<br>前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。<br>Final 变量在并发当中，原理是通过禁止cpu的指令集重排序，保证了对象的内存可见性， final 域能确保初始化过程的安全性， 防止对象引用在对象被完全构造完成前被其他线程拿到并使用（ fianl 可以保证正在创建中的对象不能被其他线程访问到）</p>
<h2 id="Semaphore有什么作用"><a href="#Semaphore有什么作用" class="headerlink" title="Semaphore有什么作用"></a>Semaphore有什么作用</h2><p>Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。<br>Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。</p>
<h2 id="进程间的通信的几种方式"><a href="#进程间的通信的几种方式" class="headerlink" title="进程间的通信的几种方式"></a>进程间的通信的几种方式</h2><p>管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；<br>信号（signal）：用于通知接收进程某个事件已经发生；<br>消息队列：<br>共享内存：可以说这是最有用的进程间通信方式。多个进程可以访问同一块内存空间<br>信号量：进程之间及同一种进程的不同线程之间得同步和互斥手段<br>套接字：用于网络中不同机器之间的进程间通信</p>
<h2 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h2><p>互斥量 Synchronized/Lock：信号量 Semphare：事件(信号)，Wait/Notify</p>
<p>为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里？<br>在Java中，任意对象都可以当作锁来使用，由于锁对象的任意性，所以这些通信方法需要被定义在Object类里。<br>为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？其目的在于确保等待线程从Wait()返回时能够感知通知线程对共享变量所作出的修改。如果不在同步范围内使用，就会抛出java.lang.IllegalMonitorStateException的异常。</p>
<h2 id="CopyOnWrite是什么？"><a href="#CopyOnWrite是什么？" class="headerlink" title="CopyOnWrite是什么？"></a>CopyOnWrite是什么？</h2><p>即写时复制的容器，适用于读操作远多于修改操作的并发场景中，先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。是一种读写分离的思想，读和写不同的容器</p>
<h2 id="一个线程运行时发生异常会怎样？"><a href="#一个线程运行时发生异常会怎样？" class="headerlink" title="一个线程运行时发生异常会怎样？"></a>一个线程运行时发生异常会怎样？</h2><p>如果异常没有被捕获该线程将会停止执行。</p>
<h2 id="分布式锁的实现，目前比较常用的有以下几种方案"><a href="#分布式锁的实现，目前比较常用的有以下几种方案" class="headerlink" title="分布式锁的实现，目前比较常用的有以下几种方案"></a>分布式锁的实现，目前比较常用的有以下几种方案</h2><p>分布式锁应该是怎么样的？<br>1）可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。<br>2）这锁要是一把可重入锁（避免死锁）<br>3）这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）<br>4）有高可用的获取锁和释放锁功能<br>5）获取锁和释放锁的性能要好</p>
<p>1）基于数据库实现分布式锁<br>1）最简单的方式可能就是直接创建一张锁表<br>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。<br>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。<br>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。<br>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</p>
<p>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。<br>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。<br>非阻塞的？搞一个while循环，直到insert成功再返回成功。<br>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</p>
<p>2） 借助数据中自带的锁来实现分布式的锁（select *** for update）<br>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。 通过connection.commit()操作来释放锁</p>
<p>基于缓存（redis，memcached，tair）实现分布式锁<br>基于 REDIS 的 SETNX()、EXPIRE() 方法（ 设置过期时间）做分布式锁</p>
<p>基于Zookeeper实现分布式锁<br>每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
<h2 id="ConcurrentHashMap-的size-方法如何实现同步的？"><a href="#ConcurrentHashMap-的size-方法如何实现同步的？" class="headerlink" title="ConcurrentHashMap 的size()方法如何实现同步的？"></a>ConcurrentHashMap 的size()方法如何实现同步的？</h2><p>1） JDK 8 推荐使用mappingCount 方法（另外的叫size方法），因为这个方法的返回值是 long 类型，不会因为 size 方法是 int 类型限制最大值<br>2）在没有并发的情况下，使用一个名为 baseCount 的volatile 变量就足够了，当并发的时候，CAS 修改 baseCount 失败后，就会使用 CounterCell 类了，会创建一个这个对象，通常对象的 volatile value 属性是 1。在计算 size 的时候，会将 baseCount 和 CounterCell 数组中的元素的 value 累加，得到总的大小，但这个数字仍旧可能是不准确的。<br>3） 还有一个需要注意的地方就是，这个 CounterCell 类使用了 @sun.misc.Contended 注解标识，这个注解是防止伪共享的。是 1.8 新增的。使用时，需要加上 -XX:-RestrictContended 参数。size（）/mappingCount（）–&gt;sumCount(){使用了baseCount变量和CounterCell数组}，在put的时候调用了 addCount（）方法</p>
<p>JDK1.7 和 JDK1.8 对 size 的计算是不一样的。 1.7 中是先不加锁计算三次，如果三次结果不一样在加锁JDK1.8 size 是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。</p>
<h2 id="notify和notifyAll方法的区别"><a href="#notify和notifyAll方法的区别" class="headerlink" title="notify和notifyAll方法的区别"></a>notify和notifyAll方法的区别</h2><p>notify只会唤醒等待该锁的其中一个线程。notifyAll：唤醒等待该锁的所有线程。<br>1）永远在while循环里而不是if语句下使用wait。这样，循环会在线程睡眠前后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知。<br>2）永远在synchronized的函数或对象里使用wait、notify和notifyAll，不然Java虚拟机会生成 IllegalMonitorStateException。</p>
<h2 id="如何判断线程是否安全？"><a href="#如何判断线程是否安全？" class="headerlink" title="如何判断线程是否安全？"></a>如何判断线程是否安全？</h2><p>考虑原子性，可见性，有序性。<br>1.明确哪些代码是多线程运行的代码,<br>2.明确共享数据 对共享变量的操作是不是原子操作 ， 当某一个线程对共享变量进行修改的时候，对其他线程是可见的<br>保证原子性的是加锁或者同步， 提供了volatile关键字来保证可见性， synchronized和锁和 volatile都能保证有序性<br>JVM还通过被称为happens-before原则隐式地保证顺序性。<br>3.明确多线程运行代码中哪些语句是操作共享数据.</p>
<p>1.该对象是否会被多个线程访问修改 ，是的话是否有加锁操作。<br>2.注意静态变量. ,由于静态变量是属于该类和该类下所有对象共享,可直接通过类名访问/修改,因此在多线程的环境下.可以断言所有对静态变量的修改都会发生线程安全问题</p>
<h2 id="ConcurrentHashMap的实现原理"><a href="#ConcurrentHashMap的实现原理" class="headerlink" title="ConcurrentHashMap的实现原理"></a>ConcurrentHashMap的实现原理</h2><p>分段机制、包含桶、红黑树</p>
<h2 id="LinkedBlockingQueue-有序阻塞队列实现原理"><a href="#LinkedBlockingQueue-有序阻塞队列实现原理" class="headerlink" title="LinkedBlockingQueue 有序阻塞队列实现原理"></a>LinkedBlockingQueue 有序阻塞队列实现原理</h2><p>满了、空了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Hannibal</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://liwenchang.ren/2020/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/">http://liwenchang.ren/2020/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liwenchang.ren" target="_blank">木子文昍</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2020/12/03/SpringCloud%E7%9F%A5%E8%AF%86%E7%82%B9/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringCloud知识点</div></div></a></div></nav></div><div class="aside_content" id="aside_content"><div class="card-widget card-info"><div class="card-content"><div class="card-info-avatar is-center"><img class="avatar-img" src="/null" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Hannibal</div><div class="author-info__description">虽不能至，心向往之</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div></div><div class="card-widget card-announcement"><div class="card-content"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="card-content"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">多线程知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">线程和进程的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E5%92%8CRunnable%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">Thread和Runnable的关系，区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">synchronized底层如何实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%AD%98%E6%94%BE%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.</span> <span class="toc-text">synchronized存放的位置:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">锁优化，怎么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">多线程中 synchronized 锁升级的原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">1.7.</span> <span class="toc-text">锁的升级的目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Synchronized%E5%92%8CLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">Synchronized和Lock的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%92%8CReentrantLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">synchronized和ReentrantLock有什么区别呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.</span> <span class="toc-text">线程池的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text">线程池的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.12.</span> <span class="toc-text">实现线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9C%80%E8%A6%81%E8%A6%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E3%80%82"><span class="toc-number">1.13.</span> <span class="toc-text">线程的组成创建一个线程池需要要的一些核心参数。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.14.</span> <span class="toc-text">运行机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%B9%B6%E5%8F%91%E7%B1%BB%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">1.15.</span> <span class="toc-text">Java 并发类库提供的线程池有哪几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.16.</span> <span class="toc-text">ReentrantLock 底层实现  可重入锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-%E5%92%8Cunlock-%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">lock()和unlock()是怎么实现的呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AtomicInteger%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">AtomicInteger底层实现原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#voliate-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.19.</span> <span class="toc-text">voliate 的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#happens-before%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9A"><span class="toc-number">1.20.</span> <span class="toc-text">happens-before原则有哪些：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E5%92%8C-volatile-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">synchronized 和 volatile 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">1.22.</span> <span class="toc-text">ThreadLocal的底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.23.</span> <span class="toc-text">线程池的几种方式与使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC%E5%8C%85%E4%B8%ADCountDownLatch-CyclicBarrier%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.24.</span> <span class="toc-text">JUC包中CountDownLatch CyclicBarrier之间的区别，使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E3%80%82%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">1.25.</span> <span class="toc-text">死锁是什么，产生死锁的条件。如何避免死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">怎么定位死锁线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E5%8F%98%E9%87%8F%E5%92%8C-atomic-%E5%8F%98%E9%87%8F%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.27.</span> <span class="toc-text">volatile 变量和 atomic 变量有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8wait-%E5%92%8C-sleep-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.28.</span> <span class="toc-text">Java多线程中调用wait() 和 sleep()方法有什么不同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%EF%BC%9F%E5%9C%A8Java-Concurrency-API%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%AD%90%E7%B1%BB-atomic-classes-%EF%BC%9F"><span class="toc-number">1.29.</span> <span class="toc-text">什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%93%AA%E4%BA%9B-%EF%BC%9F"><span class="toc-number">1.30.</span> <span class="toc-text">线程的状态有哪些 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">线程的 run() 和 start() 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runnable%E5%92%8CCallable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.32.</span> <span class="toc-text">Runnable和Callable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAS"><span class="toc-number">1.33.</span> <span class="toc-text">什么是CAS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS"><span class="toc-number">1.34.</span> <span class="toc-text">什么是AQS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.35.</span> <span class="toc-text">Semaphore有什么作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.36.</span> <span class="toc-text">进程间的通信的几种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.37.</span> <span class="toc-text">线程同步的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWrite%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.38.</span> <span class="toc-text">CopyOnWrite是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%91%E7%94%9F%E5%BC%82%E5%B8%B8%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.39.</span> <span class="toc-text">一个线程运行时发生异常会怎样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%9B%AE%E5%89%8D%E6%AF%94%E8%BE%83%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">1.40.</span> <span class="toc-text">分布式锁的实现，目前比较常用的有以下几种方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap-%E7%9A%84size-%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">1.41.</span> <span class="toc-text">ConcurrentHashMap 的size()方法如何实现同步的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notify%E5%92%8CnotifyAll%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.42.</span> <span class="toc-text">notify和notifyAll方法的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">如何判断线程是否安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.44.</span> <span class="toc-text">ConcurrentHashMap的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedBlockingQueue-%E6%9C%89%E5%BA%8F%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.45.</span> <span class="toc-text">LinkedBlockingQueue 有序阻塞队列实现原理</span></a></li></ol></li></ol></div></div></div><div class="card-widget card-recent-post"><div class="card-content"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2020/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/" title="多线程知识点"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="多线程知识点"/></a><div class="content"><a class="title" href="/2020/12/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/" title="多线程知识点">多线程知识点</a><time datetime="2020-12-03T11:49:40.000Z" title="发表于 2020-12-03 19:49:40">2020-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/03/SpringCloud%E7%9F%A5%E8%AF%86%E7%82%B9/" title="SpringCloud知识点"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SpringCloud知识点"/></a><div class="content"><a class="title" href="/2020/12/03/SpringCloud%E7%9F%A5%E8%AF%86%E7%82%B9/" title="SpringCloud知识点">SpringCloud知识点</a><time datetime="2020-12-03T11:49:25.000Z" title="发表于 2020-12-03 19:49:25">2020-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/03/spring%E7%9F%A5%E8%AF%86%E7%82%B9/" title="spring知识点"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="spring知识点"/></a><div class="content"><a class="title" href="/2020/12/03/spring%E7%9F%A5%E8%AF%86%E7%82%B9/" title="spring知识点">spring知识点</a><time datetime="2020-12-03T11:49:10.000Z" title="发表于 2020-12-03 19:49:10">2020-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/03/Robbin%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Robbin负载均衡源码解析"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Robbin负载均衡源码解析"/></a><div class="content"><a class="title" href="/2020/12/03/Robbin%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="Robbin负载均衡源码解析">Robbin负载均衡源码解析</a><time datetime="2020-12-03T11:48:57.000Z" title="发表于 2020-12-03 19:48:57">2020-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/12/03/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Redis知识点"><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis知识点"/></a><div class="content"><a class="title" href="/2020/12/03/Redis%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Redis知识点">Redis知识点</a><time datetime="2020-12-03T11:48:35.000Z" title="发表于 2020-12-03 19:48:35">2020-12-03</time></div></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="footer-wrap"><div class="copyright">&copy;2020 By Hannibal</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="http://liwenchang.ren/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script></div></body></html>